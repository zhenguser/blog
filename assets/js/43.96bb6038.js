(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{259:function(e,r,v){"use strict";v.r(r);var a=v(19),i=Object(a.a)({},(function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"微服务电商项目"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微服务电商项目"}},[e._v("#")]),e._v(" 微服务电商项目")]),e._v(" "),v("h2",{attrs:{id:"一-微信服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-微信服务"}},[e._v("#")]),e._v(" 一.微信服务")]),e._v(" "),v("h3",{attrs:{id:"二维码生生接口-weixinqrcodeserviceimpl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二维码生生接口-weixinqrcodeserviceimpl"}},[e._v("#")]),e._v(" 二维码生生接口(WeiXinQrCodeServiceImpl)")]),e._v(" "),v("h4",{attrs:{id:"getqrurl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#getqrurl"}},[e._v("#")]),e._v(" getQrUrl")]),e._v(" "),v("p",[e._v("根据userId生成待参数连接的二维码,提供给会员服务登入接口使用。")]),e._v(" "),v("ol",[v("li",[e._v("根据appid 获取对应的  WxMpQrcodeService")]),e._v(" "),v("li",[e._v("利用WxMpQrcodeService,根据userId生成二维码的ticket")]),e._v(" "),v("li",[e._v("前端vue根据ticket拼接链接地址，生成二维码，用户扫描二维码触发关注事件（SubscribeHandler）或者扫描事件（ScanHandler）")])]),e._v(" "),v("h3",{attrs:{id:"微信关注事件（subscribehandler）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微信关注事件（subscribehandler）"}},[e._v("#")]),e._v(" 微信关注事件（SubscribeHandler）")]),e._v(" "),v("ol",[v("li",[e._v("获取用户基本信息：userId、openId")]),e._v(" "),v("li",[e._v("通过WxMpServiceManage调用会员服务的MemberInfoService服务，查询该openId是否已经关联了账号")]),e._v(" "),v("li",[e._v("若没关联，则调用会员服务的MemberInfoService服务，关联账号，否则不做关联操作")])]),e._v(" "),v("h3",{attrs:{id:"微信扫码事件（scanhandler）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微信扫码事件（scanhandler）"}},[e._v("#")]),e._v(" 微信扫码事件（ScanHandler）")]),e._v(" "),v("ol",[v("li",[e._v("通过WxMpServiceManage调用会员服务的MemberInfoService服务，查询该openId是否已经关联了账号")]),e._v(" "),v("li",[e._v("若没关联，则调用会员服务的MemberInfoService服务，关联账号，否则不做关联操作")])]),e._v(" "),v("h3",{attrs:{id:"登入消息模板-wechatlogintemplateimpl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#登入消息模板-wechatlogintemplateimpl"}},[e._v("#")]),e._v(" 登入消息模板(WeChatLoginTemplateImpl)")]),e._v(" "),v("p",[e._v("发送登入提醒")]),e._v(" "),v("h2",{attrs:{id:"二-会员服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-会员服务"}},[e._v("#")]),e._v(" 二.会员服务")]),e._v(" "),v("h3",{attrs:{id:"注册接口（memberregisterserviceimpl）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注册接口（memberregisterserviceimpl）"}},[e._v("#")]),e._v(" 注册接口（MemberRegisterServiceImpl）")]),e._v(" "),v("h4",{attrs:{id:"register"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#register"}},[e._v("#")]),e._v(" register")]),e._v(" "),v("ol",[v("li",[e._v("参数验证")]),e._v(" "),v("li",[e._v("查询数据库检查该手机号码是否存在")]),e._v(" "),v("li",[e._v("密码加密 MD5 +加盐值，插入数据库中")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("盐值生成：\n1.盐值采用时间挫或其他，存入数据库中，每个用户的盐值不一样，安全性高\n2.在配置中心定义一个常量用于盐值，但是每个用户的盐值都是一样的，安全系数低\n3.使用手机号作为盐值，会导致用户更改手机号后，登入失败")])]),e._v(" "),v("h3",{attrs:{id:"登入接口（memberloginserviceimpl）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#登入接口（memberloginserviceimpl）"}},[e._v("#")]),e._v(" 登入接口（MemberLoginServiceImpl）")]),e._v(" "),v("p",[e._v("前端vue如何绑定会话信息 前端vue使用ajax调用后端登陆接口，获取令牌存放到缓存中，每次在调用其他的接口都会传递该接口。"),v("br"),e._v("\n登陆成功之后返回令牌给客户端保存，客户端后期使用该令牌绑定会话信息")]),e._v(" "),v("h4",{attrs:{id:"login"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#login"}},[e._v("#")]),e._v(" login")]),e._v(" "),v("ol",[v("li",[e._v("参数验证\n渠道参数可放在网关中验证")]),e._v(" "),v("li",[e._v("密码采用MD5加密，根据密码查询我们的数据库，获取用户信息")]),e._v(" "),v("li",[e._v("生成token （key:采用项目前缀+uuid  value: userId）\nkey:"),v("br"),e._v("\n有效期 生成临时且唯一,采用项目前缀+uuid。\nvalue:"),v("br"),e._v("\n不要放入用户信息、手机号，这些信息都是可变的。可以放userId,拿到token可以根据value中的userId查询数据库，获取用户信息。")]),e._v(" "),v("li",[e._v("通过AsyncLoginLogManage异步日志记录\n(1)根据当前的渠道+userid+可用 查询 该用户是否已经登陆过\n(2)如果没有查询到记录,创建token存入redis中，并插入最新的token到数据库中\n(3)如果有记录，将数据库记录改为不可用，，并删除redis中的token，最后创建新的token存入redis中，并插入最新的token到数据库中\n(4)调用微信接口发送消息模版\n通过weChatLoginTemplateFeign调用微信服务WeChatLoginTemplate")])]),e._v(" "),v("p",[v("strong",[e._v("如何获取客户端真实ip地址")]),e._v("\n因为从request中获取的IP地址是gateway的，gateway中的IP地址是nginx中转发的,nginx做了代理，所以不是真实IP地址\n解决办法：\nNginx  nginx可以获取真实的客户端ip地址，存放到请求中\n请求头中设置该参数 X-Real-IP value  vue为客户端真实的ip地址")]),e._v(" "),v("p",[v("strong",[e._v("如何实现唯一登入")]),e._v("\n第一次登陆生成令牌 token"),v("br"),e._v("\n第二次登陆之后 之前的token从Redis删除掉。"),v("br"),e._v("\n在nacos中配置渠道列表"),v("br"),e._v("\n一个渠道对应只能生成一个token"),v("br"),e._v("\n流程：\n1.查询我们的登陆记录表 条件有 渠道+userid+当前token是否可用\n2.没有查询登陆记录情况下说明 该渠道对应的该用户没有登陆过直接向该表插入一条日志记录\n3.如果查询到有登陆记录的情况下，说明该账户在登陆状态，将数据库中的状态变为不可用。从redis中移除原来令牌，插入最新的登陆日志信息\n客户端实现: Ajax定时开启 每2s时间检查当前自己的token是否有失效")]),e._v(" "),v("p",[v("strong",[e._v("扫码关注")]),e._v("\n原理：\n1.判断该用户是否关注公众号\n2.如果没有关注公众号，调用微信接口生成二维码连接地址（二维码中含有参数userId，和微信用户的openId）\n如何关联：\n当用户扫描二维码时，会将二维码中的userId传递到微信回调接口，此时可以获取到关联用户的userId\n1.先根据该openId查询是否关注公众号\n2.获取userId，查询用户信息，修改openId")]),e._v(" "),v("p",[e._v("实现：\n1.生成带参数的链接,传递用户的userid，获取微信展示的二维码链接\n微信服务提供接口(WeiXinQrCodeServiceImpl getQrUrl)：\n根据userId生成待参数连接的二维码（vue直接传递userId不安全）\n解决方案：\nvue调用会员服务接口传递token获取带参数链接的二维码\n(1)根据token获取userId\n(2)调用微信服务接口,根据userId生成待参数连接的二维码\n2.用户打开手机二维码识别该二维码时，则会将该参数(userId,openId)通知给微信的回调接口\n3.回调接口获取该userid，判断该用户是否有关联过openid，没有关联则关联userid")]),e._v(" "),v("p",[e._v("微信端:\n如果用户没有关注微信公众号，不会推送扫码事件，改为推送关注事件(SubscribeHandler),\n如果该用户已关注微信公众号，推送扫码事件(ScanHandler)")]),e._v(" "),v("h3",{attrs:{id:"会员服务基本信息接口-memberinfoserviceimpl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#会员服务基本信息接口-memberinfoserviceimpl"}},[e._v("#")]),e._v(" 会员服务基本信息接口(MemberInfoServiceImpl)")]),e._v(" "),v("h4",{attrs:{id:"gettokenuser"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gettokenuser"}},[e._v("#")]),e._v(" getTokenUser")]),e._v(" "),v("p",[e._v("根据用户token查询用户的信息")]),e._v(" "),v("ol",[v("li",[e._v("从Redis中获取到userId")]),e._v(" "),v("li",[e._v("在根据userId查询用户的信息")]),e._v(" "),v("li",[e._v("将do转换成dto返回")])]),e._v(" "),v("h4",{attrs:{id:"取消关注（cancelfollowopenid）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#取消关注（cancelfollowopenid）"}},[e._v("#")]),e._v(" 取消关注（cancelFollowOpenId）")]),e._v(" "),v("ol",[v("li",[e._v("根据openId查询")]),e._v(" "),v("li",[e._v("已经关注过，则将对应的用户的openid 变为空")])]),e._v(" "),v("h3",{attrs:{id:"联合登入接口-memberunionloginserviceimpl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#联合登入接口-memberunionloginserviceimpl"}},[e._v("#")]),e._v(" 联合登入接口(MemberUnionLoginServiceImpl)")]),e._v(" "),v("p",[e._v("用户授权成功后，将对应的openId与数据库中的账户关联\n原理：")]),e._v(" "),v("ol",[v("li",[e._v("根据用户授权的的openId查询数据库是否关联账户，没有关联账户则跳转到关联页面")]),e._v(" "),v("li",[e._v("如果该用户的openId从数据库中能够查询到用户，可以实现不需要账户密码登陆")])]),e._v(" "),v("p",[e._v("oauth2.0流程：")]),e._v(" "),v("ol",[v("li",[e._v("用户选择账户授权")]),e._v(" "),v("li",[e._v("获取到授权码code")]),e._v(" "),v("li",[e._v("根据授权码获取accessToken")]),e._v(" "),v("li",[e._v("根据accessToken获取用户的openid")])]),e._v(" "),v("h4",{attrs:{id:"unionlogin"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unionlogin"}},[e._v("#")]),e._v(" unionLogin")]),e._v(" "),v("p",[e._v("联合登陆接口，返回授权码请求地址")]),e._v(" "),v("ol",[v("li",[e._v("根据参数unionPublicId查询数据库，获取联合基本信息beanId")])]),e._v(" "),v("h4",{attrs:{id:"unionlogincallback"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unionlogincallback"}},[e._v("#")]),e._v(" unionLoginCallback")]),e._v(" "),v("p",[e._v("联合登入回调地址")]),e._v(" "),v("ol",[v("li",[e._v("根据参数unionPublicId查询数据库，获取联合基本信息beanId")]),e._v(" "),v("li",[e._v("从Spring容器中根据beanid 查找到我们的策略类")]),e._v(" "),v("li",[e._v("利用策略类获取openId，创建token并将openId等敏感信息存入redis中，返回token给vue")])]),e._v(" "),v("h2",{attrs:{id:"三-会员定时任务服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三-会员定时任务服务"}},[e._v("#")]),e._v(" 三.会员定时任务服务")]),e._v(" "),v("p",[v("strong",[e._v("定时任务数量大的情况下如何处理")]),e._v("\n1.采用多线程，但是非常消耗单台哦服务器的内存\n"),v("strong",[e._v("在集群中，如何保证定时任务只会触发一次")])]),e._v(" "),v("ol",[v("li",[e._v("将业务逻辑和定时任务逻辑完全分开部署，只对业务逻辑实现集群，不对我们的定时任务逻辑集群；")]),e._v(" "),v("li",[e._v("对我们Jar包加上一个开关，项目启动的时候读取该开关   如果为true的情况下则加载定时任务类，否则情况下就不加载该定时任务类；")]),e._v(" "),v("li",[e._v("在数据库加上一个主键能够创建成功，则触发定时任务，否则就不触发定时任务；")]),e._v(" "),v("li",[e._v("分布式锁实，只要jar能够拿到分布式锁就能够执行定时任务，否则情况下不执行；\n以上的方案都是属于规模比较小的项目，在微服务架构中应该采用分布式任务调度平台。\n"),v("strong",[e._v("分布式任务调度平台")])]),e._v(" "),v("li",[e._v("定时任务的项目将自己服务器地址注册到分布式任务调度平台中；")]),e._v(" "),v("li",[e._v("我们的定时任务的规则都会在“分布式任务调度中心”触发；")]),e._v(" "),v("li",[e._v("当我们的任务调度中心触发定时任务规则时，读取“定时任务项目服务器集群地址”，取一个定时任务地址，调度中心向定时任务发一个通知根据java反射机制执行定时任务项目。")])]),e._v(" "),v("h2",{attrs:{id:"四-支付服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四-支付服务"}},[e._v("#")]),e._v(" 四.支付服务")]),e._v(" "),v("h3",{attrs:{id:"订单调用支付服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#订单调用支付服务"}},[e._v("#")]),e._v(" 订单调用支付服务")]),e._v(" "),v("p",[e._v("订单调用支付服务预插入支付信息")]),e._v(" "),v("ol",[v("li",[e._v("验证参数")]),e._v(" "),v("li",[e._v("生成支付的全局的payment_Id（雪花算法）")]),e._v(" "),v("li",[e._v("支付详细表插入呆支付记录")]),e._v(" "),v("li",[e._v("生成token令牌 （key:采用项目前缀+uuid  value: 预支付id）")])]),e._v(" "),v("h3",{attrs:{id:"支付接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#支付接口"}},[e._v("#")]),e._v(" 支付接口")]),e._v(" "),v("ol",[v("li",[e._v("验证参数")]),e._v(" "),v("li",[e._v("根据渠道id查询到详细渠道的信息")]),e._v(" "),v("li",[e._v("根据beanid 从Spring容器中找到策略类执行")]),e._v(" "),v("li",[e._v("根据payToken查询到支付ID")]),e._v(" "),v("li",[e._v("根据支付ID获取我们的预支付的参数的信息")]),e._v(" "),v("li",[e._v("统一返回html表单给客户端")])]),e._v(" "),v("h3",{attrs:{id:"异步回调接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步回调接口"}},[e._v("#")]),e._v(" 异步回调接口")]),e._v(" "),v("ol",[v("li",[e._v("根据渠道id查询渠道信息")]),e._v(" "),v("li",[e._v("获取模板的baenid")]),e._v(" "),v("li",[e._v("直接从Spring容器上下文获取模板类\n3.1 验证签名\n3.2 记录日志 注意问题：一定要是异步，提高快速响应给支付宝，避免重试造成的幂等性问题\n3.3 调用子模板类的子类\n3.3.1  根据支付订单号码查询数据库 ，是否已经支付过\n3.3.2  判断支付的金额 是否一致\n3.3.3  修改为已经支付状态\n3.3.4  调用积分服务接口增加积分 分布式失误的问题")])]),e._v(" "),v("h2",{attrs:{id:"积分服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#积分服务"}},[e._v("#")]),e._v(" 积分服务")]),e._v(" "),v("h2",{attrs:{id:"秒杀服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#秒杀服务"}},[e._v("#")]),e._v(" 秒杀服务")]),e._v(" "),v("p",[e._v("用户秒杀成功——>下订单成功——>库存减去1——>跳转到聚合支付平台支付\n答：订单超时设计，基于Redis过期Key或者MQ延迟队列实现")]),e._v(" "),v("p",[e._v("如何防止超卖的问题\n答：在mysql中不能多个线程对同一行数据进行操作，自带行锁机制，避免脏读问题")]),e._v(" "),v("p",[e._v("基于Redis对用户频率进行限制")])])}),[],!1,null,null,null);r.default=i.exports}}]);