(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{255:function(t,n,e){"use strict";e.r(n);var s=e(19),a=Object(s.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"数据库设计的范式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计的范式"}},[this._v("#")]),this._v(" 数据库设计的范式")]),this._v(" "),n("ul",[n("li",[n("p",[this._v("概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[this._v("  \t设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n  \t目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n\n  * 分类：\n  \t1. 第一范式（1NF）：每一列都是不可分割的原子数据项\n  \t2. 第二范式（2NF）：在1NF的于码（在1NF基础上消除非主属性对主码的部分函数依赖）\n  \t\t* 几个概念：\n  \t\t\t1. 函数依赖：A--\x3eB,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A\n  \t\t\t\t例如：学号--\x3e姓名。  （学号，课程名称） --\x3e 分数\n  \t\t\t2. 完全函数依赖：A--\x3eB， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。\n  \t\t\t\t例如：（学号，课程名称） --\x3e 分数\n  \t\t\t3. 部分函数依赖：A--\x3eB， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。\n  \t\t\t\t例如：（学号，课程名称） -- > 姓名\n  \t\t\t4. 传递函数依赖：A--\x3eB, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A\n  \t\t\t\t例如：学号--\x3e系名，系名--\x3e系主任\n  \t\t\t5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码\n  \t\t\t\t例如：该表中码为：（学号，课程名称）\n  \t\t\t\t* 主属性：码属性组中的所有属性\n  \t\t\t\t* 非主属性：除过码属性组的属性\n  \t3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）")])])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);