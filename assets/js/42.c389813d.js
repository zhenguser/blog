(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{260:function(_,v,e){"use strict";e.r(v);var a=e(19),t=Object(a.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql-联合索引的命中规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql-联合索引的命中规则"}},[_._v("#")]),_._v(" MySQL 联合索引的命中规则")]),_._v(" "),e("p",[_._v("联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。")]),_._v(" "),e("p",[_._v("两个或更多个列上的索引被称作复合索引。\n利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。\n所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。")]),_._v(" "),e("p",[_._v("当一个表有多条索引可走时,  Mysql  根据查询语句的成本来选择走哪条索引, 联合索引的话, 它往往计算的是第一个字段(最左边那个), 这样往往会走错索引. 如:\n索引Index_1(Create_Time, Category_ID), Index_2(Category_ID)")]),_._v(" "),e("p",[_._v("如果每天的数据都特别多, 而且有很多category, 但具体每个category的记录不会很多.")]),_._v(" "),e("p",[_._v("当查询SQL条件为select …where create_time ….and category_id=..时, 很可能不走索引Index_1, 而走索引Index_2, 导致查询比较慢.")]),_._v(" "),e("p",[_._v("解决办法是将索引字段的顺序调换一下.")]),_._v(" "),e("h2",{attrs:{id:"创建索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建索引"}},[_._v("#")]),_._v(" 创建索引")]),_._v(" "),e("p",[_._v("在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。")]),_._v(" "),e("ol",[e("li",[_._v("ALTER TABLE\nALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。")])]),_._v(" "),e("p",[_._v("ALTER TABLE table_name ADD INDEX index_name (column_list)")]),_._v(" "),e("p",[_._v("ALTER TABLE table_name ADD UNIQUE (column_list)")]),_._v(" "),e("p",[_._v("ALTER TABLE table_name ADD PRIMARY KEY (column_list)")]),_._v(" "),e("p",[_._v("其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。")]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[_._v("CREATE INDEX\nCREATE INDEX可对表增加普通索引或UNIQUE索引。")])]),_._v(" "),e("p",[_._v("CREATE INDEX index_name ON table_name (column_list)")]),_._v(" "),e("p",[_._v("CREATE UNIQUE INDEX index_name ON table_name (column_list)")]),_._v(" "),e("p",[_._v("table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。")]),_._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[_._v("索引类型\n在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。")])]),_._v(" "),e("p",[_._v("PRIMARY KEY索引和UNIQUE索引非常类似。\n事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。")]),_._v(" "),e("p",[_._v("下面的SQL语句对students表在sid上添加PRIMARY KEY索引。")]),_._v(" "),e("p",[_._v("ALTER TABLE students ADD PRIMARY KEY (sid)")]),_._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[_._v("删除索引\n可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。")])]),_._v(" "),e("p",[_._v("DROP INDEX index_name ON talbe_name")]),_._v(" "),e("p",[_._v("ALTER TABLE table_name DROP INDEX index_name")]),_._v(" "),e("p",[_._v("ALTER TABLE table_name DROP PRIMARY KEY")]),_._v(" "),e("p",[_._v("其中，前两条语句是等价的，删除掉table_name中的索引index_name。")]),_._v(" "),e("p",[_._v("第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。")]),_._v(" "),e("p",[_._v("如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。")]),_._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[_._v("查看索引")])]),_._v(" "),e("p",[_._v("mysql> show index from tblname;")]),_._v(" "),e("p",[_._v("mysql> show keys from tblname;\n　　· Table")]),_._v(" "),e("p",[_._v("表的名称。")]),_._v(" "),e("p",[_._v("· Non_unique")]),_._v(" "),e("p",[_._v("如果索引不能包括重复词，则为0。如果可以，则为1。")]),_._v(" "),e("p",[_._v("· Key_name")]),_._v(" "),e("p",[_._v("索引的名称。")]),_._v(" "),e("p",[_._v("· Seq_in_index")]),_._v(" "),e("p",[_._v("索引中的列序列号，从1开始。")]),_._v(" "),e("p",[_._v("· Column_name")]),_._v(" "),e("p",[_._v("列名称。")]),_._v(" "),e("p",[_._v("· Collation")]),_._v(" "),e("p",[_._v("列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。")]),_._v(" "),e("p",[_._v("· Cardinality")]),_._v(" "),e("p",[_._v("索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。")]),_._v(" "),e("p",[_._v("· Sub_part")]),_._v(" "),e("p",[_._v("如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。")]),_._v(" "),e("p",[_._v("· Packed")]),_._v(" "),e("p",[_._v("指示关键字如何被压缩。如果没有被压缩，则为NULL。")]),_._v(" "),e("p",[_._v("· Null")]),_._v(" "),e("p",[_._v("如果列含有NULL，则含有YES。如果没有，则该列含有NO。")]),_._v(" "),e("p",[_._v("· Index_type")]),_._v(" "),e("p",[_._v("用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。")]),_._v(" "),e("p",[_._v("· Comment")]),_._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[_._v("什么情况下使用索引\n表的主关键字")])]),_._v(" "),e("p",[_._v("自动建立唯一索引")]),_._v(" "),e("p",[_._v("如zl_yhjbqk（用户基本情况）中的hbs_bh（户标识编号）")]),_._v(" "),e("p",[_._v("表的字段唯一约束")]),_._v(" "),e("p",[_._v("ORACLE利用索引来保证数据的完整性")]),_._v(" "),e("p",[_._v("如lc_hj（流程环节）中的lc_bh+hj_sx（流程编号+环节顺序）")]),_._v(" "),e("p",[_._v("直接条件查询的字段")]),_._v(" "),e("p",[_._v("在SQL中用于条件约束的字段")]),_._v(" "),e("p",[_._v("如zl_yhjbqk（用户基本情况）中的qc_bh（区册编号）")]),_._v(" "),e("p",[_._v("select * from zl_yhjbqk where qc_bh=’<????甼曀???>7001’")]),_._v(" "),e("p",[_._v("查询中与其它表关联的字段")]),_._v(" "),e("p",[_._v("字段常常建立了外键关系")]),_._v(" "),e("p",[_._v("如zl_ydcf（用电成份）中的jldb_bh（计量点表编号）")]),_._v(" "),e("p",[_._v("select * from zl_ydcf a,zl_yhdb b where a.jldb_bh=b.jldb_bh and b.jldb_bh=’540100214511’")]),_._v(" "),e("p",[_._v("查询中排序的字段")]),_._v(" "),e("p",[_._v("排序的字段如果通过索引去访问那将大大提高排序速度")]),_._v(" "),e("p",[_._v("select * from zl_yhjbqk order by qc_bh（建立qc_bh索引）")]),_._v(" "),e("p",[_._v("select * from zl_yhjbqk where qc_bh=’7001’ order by cb_sx（建立qc_bh+cb_sx索引，注：只是一个索引，其中包括qc_bh和cb_sx字段）")]),_._v(" "),e("p",[_._v("查询中统计或分组统计的字段")]),_._v(" "),e("p",[_._v("select max(hbs_bh) from zl_yhjbqk")]),_._v(" "),e("p",[_._v("select qc_bh,count(*) from zl_yhjbqk group by qc_bh")]),_._v(" "),e("p",[_._v("什么情况下应不建或少建索引")]),_._v(" "),e("p",[_._v("表记录太少")]),_._v(" "),e("p",[_._v("如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块，这种情况下ORACLE至少要往返读取数据块两次。而不用索引的情况下ORACLE会将所有的数据一次读出，处理速度显然会比用索引快。")]),_._v(" "),e("p",[_._v("如表zl_sybm（使用部门）一般只有几条记录，除了主关键字外对任何一个字段建索引都不会产生性能优化，实际上如果对这个表进行了统计分析后ORACLE也不会用你建的索引，而是自动执行全表访问。如：")]),_._v(" "),e("p",[_._v("select * from zl_sybm where sydw_bh=’5401’（对sydw_bh建立索引不会产生性能优化）")]),_._v(" "),e("p",[_._v("经常插入、删除、修改的表")]),_._v(" "),e("p",[_._v("对一些经常处理的业务表应在查询允许的情况下尽量减少索引，如zl_yhbm，gc_dfss，gc_dfys，gc_fpdy等业务表。")]),_._v(" "),e("p",[_._v("数据重复且分布平均的表字段")]),_._v(" "),e("p",[_._v("假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。")]),_._v(" "),e("p",[_._v("经常和主字段一块查询但主字段索引值比较多的表字段")]),_._v(" "),e("p",[_._v("如gc_dfss（电费实收）表经常按收费序号、户标识编号、抄表日期、电费发生年月、操作 标志来具体查询某一笔收款的情况，如果将所有的字段都建在一个索引里那将会增加数据的修改、插入、删除时间，从实际上分析一笔收款如果按收费序号索引就已 经将记录减少到只有几条，如果再按后面的几个字段索引查询将对性能不产生太大的影响。")]),_._v(" "),e("p",[_._v("对千万级MySQL数据库建立索引的事项及提高性能的手段")]),_._v(" "),e("p",[_._v("一、注意事项：")]),_._v(" "),e("p",[_._v("首先，应当考虑表空间和磁盘空间是否足够。我们知道索引也是一种数据，在建立索引的时候势必也会占用大量表空间。因此在对一大表建立索引的时候首先应当考虑的是空间容量问题。")]),_._v(" "),e("p",[_._v("其次，在对建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行。")]),_._v(" "),e("p",[_._v("二、性能调整方面：")]),_._v(" "),e("p",[_._v("首当其冲的考虑因素便是磁盘I/O。物理上，应当尽量把索引与数据分散到不同的磁盘上（不考虑阵列的情况）。逻辑上，数据表空间与索引表空间分开。这是在建索引时应当遵守的基本准则。")]),_._v(" "),e("p",[_._v("其次，我们知道，在建立索引的时候要对表进行全表的扫描工作，因此，应当考虑调大初始化参数db_file_multiblock_read_count的值。一般设置为32或更大。")]),_._v(" "),e("p",[_._v("再次，建立索引除了要进行全表扫描外同时还要对数据进行大量的排序操作，因此，应当调整排序区的大小。")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("9i之前，可以在session级别上加大sort_area_size的大小，比如设置为100m或者更大。\n\n9i以后，如果初始化参数workarea_size_policy的值为TRUE，则排序区从pga_aggregate_target里自动分配获得。\n")])])]),e("p",[_._v("最后，建立索引的时候，可以加上nologging选项。以减少在建立索引过程中产生的大量redo，从而提高执行的速度。")]),_._v(" "),e("p",[_._v("MySql在建立索引优化时需要注意的问题")]),_._v(" "),e("p",[_._v("设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：")]),_._v(" "),e("p",[_._v("1，创建索引")]),_._v(" "),e("p",[_._v("对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加")]),_._v(" "),e("p",[_._v("索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。\n但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。")]),_._v(" "),e("p",[_._v("2，复合索引")]),_._v(" "),e("p",[_._v("比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;")]),_._v(" "),e("p",[_._v("如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效")]),_._v(" "),e("p",[_._v("率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。\n因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。")]),_._v(" "),e("p",[_._v("3，索引不会包含有NULL值的列")]),_._v(" "),e("p",[_._v("只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。")]),_._v(" "),e("p",[_._v("4，使用短索引")]),_._v(" "),e("p",[_._v("对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。")]),_._v(" "),e("p",[_._v("5，排序的索引问题")]),_._v(" "),e("p",[_._v("mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。")]),_._v(" "),e("p",[_._v("6，like语句操作")]),_._v(" "),e("p",[_._v("一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。")]),_._v(" "),e("p",[_._v("7，不要在列上进行运算")]),_._v(" "),e("p",[_._v("select * from users where")]),_._v(" "),e("p",[_._v("YEAR(adddate)")]),_._v(" "),e("p",[_._v("8，不使用NOT IN和操作\nNOT IN和操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id3则可使用id>3 or id")]),_._v(" "),e("h2",{attrs:{id:"一级、二级、三级封锁协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一级、二级、三级封锁协议"}},[_._v("#")]),_._v(" 一级、二级、三级封锁协议")]),_._v(" "),e("p",[_._v("在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。不同的封锁协议，在不同的程度上为并发操作的正确调度提供一定的保证。")]),_._v(" "),e("h3",{attrs:{id:"一级封锁协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一级封锁协议"}},[_._v("#")]),_._v(" 一级封锁协议")]),_._v(" "),e("p",[_._v("一级封锁协议是：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束   （ROLLBACK）。　"),e("br"),_._v("\n一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。"),e("br"),_._v("\n在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。")]),_._v(" "),e("h3",{attrs:{id:"二级封锁协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二级封锁协议"}},[_._v("#")]),_._v(" 二级封锁协议")]),_._v(" "),e("p",[_._v("二级封锁协议是：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。"),e("br"),_._v("\n二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。")]),_._v(" "),e("h3",{attrs:{id:"三级封锁协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三级封锁协议"}},[_._v("#")]),_._v(" 三级封锁协议")]),_._v(" "),e("p",[_._v("三级封锁协议是：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。   　　\n三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。   　\n上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。")])])}),[],!1,null,null,null);v.default=t.exports}}]);